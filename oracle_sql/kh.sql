select * from employee;

select emp_name from employee;

select emp_name, email, phone from employee;

select * from employee where emp_name = '선동일';

select EMP_NAME, PHONE from employee where JOB_CODe = 'J5';

select job_name from job;

select * from department;

select emp_name,email,phone,salary from employee;

select emp_name,email,phone,salary from employee where salary >= 2500000;

select emp_name,email,phone,salary from employee where salary >= 2500000 and job_code = 'J3';

SELECT EMP_NAME, SALARY, SALARY*12 FROM EMPLOYEE;

SELECT * FROM EMPLOYEE;

SELECT 
    EMP_NAME AS "이름", SALARY AS "월급", SALARY*12 AS "연봉",
    (SALARY+(SALARY*BONUS))*12 AS "보너스포함"
FROM EMPLOYEE;
SELECT 
    EMP_NAME, SALARY,'원'"단위"
FROM
    EMPLOYEE;
    
SELECT EMP_NAME, SALARY||'원' FROM EMPLOYEE;

-- 급여가 350만원 이상 600만원 이하인 직원의 이름, 급여 출력
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY>=3500000 AND SALARY <= 6000000;

-- 

SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY BETWEEN 3500000 AND 6000000;

-- LIKE, NOT LIKE
-- 와일드카드 %,_
-- % : 글자 수 제한없이 대체
-- _ : 한 글자를 대체

SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE EMP_NAME LIKE '전__';

SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE EMP_NAME LIKE '전%';

-- 이메일에서 _앞이 3글자인 직원 조회
SELECT EMP_NAME, EMAIL FROM EMPLOYEE WHERE EMAIL NOT LIKE '___#_%'ESCAPE'#';


-- 1. EMPLOYEE 테이블에서 이름 끝이 연으로 끝나는 사원의 이름, 급여 출력
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE EMP_NAME LIKE '__연';

-- 2. EMPLOYEE 테이블에서 전화번호 첫 3자리가 010이 아닌 직원의 이름,전화
SELECT EMP_NAME, PHONE FROM EMPLOYEE WHERE PHONE NOT LIKE '010%';

-- 3. EMPLOYEE 테이블에서 이메일 주소에 s가 들어가면서, DEPT_DODE가 D9 또는 D6인 직원의 이름, 이메일, 부서코드(DEPT_CODE)

SELECT EMP_NAME, EMAIL, DEPT_CODE FROM EMPLOYEE WHERE EMAIL LIKE '%s%' and (DEPT_CODE = 'D9' OR DEPT_CODE = 'D6');
--NULL은 IS, IS NOT로 검색 = 사용 못함
SELECT EMP_NAME, SALARY, BONUS FROM EMPLOYEE WHERE BONUS IS NOT NULL;

-- EMPLOYEE 테이블에서 이름, 부서코드
-- 부서코드(DEPT_CODE)가 D9 또는 D8인 직원

--셋 중 하나 포함
SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE WHERE DEPT_CODE IN ('D9','D6','D8');
--셋 중 어느것도 포함되지 않는 것
SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE WHERE DEPT_CODE NOT IN ('D9','D6','D8');

--------------------------------------------------------------------------------
-- LENTH : 문자열의 길이 반환
SELECT EMP_NAME,LENGTH(EMP_NAME), EMAIL, LENGTH(EMAIL) FROM EMPLOYEE;

-- LENGTHB : 문자열 BYTE 반환
SELECT EMP_NAME, LENGTHB(EMP_NAME), EMAIL, LENGTHB(EMAIL) FROM EMPLOYEE;

-- INSTR : 찾는 문자열이 지정한 위치부터 지정한 획수에 나타난 위치 반환
SELECT 'Hello World Hi High' FROM DUAL;

SELECT INSTR('Hello World Hi High', 'H',-1,1) FROM DUAL;

SELECT EMP_NAME, EMAIL, INSTR(EMAIL,'@',1,1) FROM EMPLOYEE;

--LPAD/RPAD : 주어진 컬럼 문자열에 임의의 문자열을 왼쪽 /오른쪽에 덧붙임

SELECT EMAIL, LENGTH(EMAIL),LPAD(EMAIL,20,'#'),RPAD(EMAIL,20,'#') FROM EMPLOYEE;

-- LTRIM/RTRIM : 주어진 컬럼이나 문자열의 왼쪽 또는 오른쪽에서 지정한 문자열에 포함된 모든 문자를 제거한 나머지 반환

SELECT '000KH000' FROM DUAL;
SELECT LTRIM('000KH000','0') FROM DUAL;
SELECT LTRIM('1233211232112KH000','123') FROM DUAL;
SELECT RTRIM('000KH1231233213212321231123','123') FROM DUAL;
-- TRIM : 주어진 컬럼이나 문자열의 앞/뒤/양쪽에 있는 지정한 문자를 제거한 나머지 반환
SELECT '000KH000' FROM DUAL;
SELECT TRIM('0' FROM '000KH000') FROM DUAL;
SELECT TRIM(BOTH '0' FROM '000KH000') FROM DUAL;
SELECT TRIM(LEADING '0' FROM '000KH000') FROM DUAL;
SELECT TRIM(TRAILING '0' FROM '000KH000') FROM DUAL;

--SUBSTR : 컬럼이나 문자열에서 지정한 위치부터 지정한 개수의 문자열을 잘라내어 리턴
SELECT 'SHOW ME THE MONEY' FROM DUAL;
SELECT SUBSTR('SHOW ME THE MONEY',6,2) FROM DUAL;
SELECT SUBSTR('SHOW ME THE MONEY',9,3) FROM DUAL;
SELECT SUBSTR('SHOW ME THE MONEY',9) FROM DUAL;
SELECT SUBSTR('SHOW ME THE MONEY',-9,3) FROM DUAL;

-- 1. EMPLOYEE테이블에서 사원 이름 중 성만 출력
SELECT EMP_NAME,SUBSTR(EMP_NAME,1,1) FROM EMPLOYEE;


-- 2. EMPLOYEE테이블에서 남자사원만 사원번호, 이름, 주민번호, 월급
SELECT DEPT_CODE, EMP_NAME,  RPAD(SUBSTR(EMP_NO,1,8),14,'*'),SALARY FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=1;

-- 단, 주민번호 출력시 뒤 6자리는 *로 출력

select * from employee;

-- LOWER / UPPER / INITCAP
SELECT LOWER('Welcome To Oracle') FROM DUAL;
SELECT UPPER('Welcome To Oracle') FROM DUAL;
SELECT INITCAP('Welcome To Oracle') FROM DUAL;

-- CONCAT : 문자열을 두개를 받아 하나로 합쳐서 리턴
SELECT CONCAT(CONCAT('가나다라','ABCD'),'1111') FROM DUAL;
SELECT '가나다라'||'ABCD'||'1111' FROM DUAL;

-- REPLACE(STR1, STR2, STR3) : 문자열 3개를 매개변수로 받아서 
-- STR1문자열중 STR2의 내용을 STR3으로 수정
SELECT REPLACE(EMAIL, 'kh','iei') FROM EMPLOYEE;
------------------------------------------------------------------------------
--ABS : 절대값
SELECT ABS(10),ABS(-10) FROM DUAL;
--MOD :나머지연산
SELECT MOD(10,3) FROM DUAL;
--ROUND : 반올림
SELECT ROUND(123.456) FROM DUAL;
SELECT ROUND(123.456,1)FROM DUAL;
SELECT ROUND(123.456,2)FROM DUAL;
SELECT ROUND(123.456,-1) FROM DUAL;
SELECT ROUND(123.456,-2) FROM DUAL;
--FLOOR : 버림/소수점 통재로 버림
SELECT FLOOR(123.567) FROM DUAL;--자리수 지정 안됨
--TRUNC : 소수점 자리수 버림
SELECT TRUNC(123.567,1) FROM DUAL;
SELECT TRUNC(123.567,-1) FROM DUAL;
--CEIL : 올림
SELECT CEIL(123.456) FROM DUAL;--자리수 지정 안됨
----------------------------------------------------------------------------
--현재시간을 다루는 함수
SELECT SYSDATE, CURRENT_DATE, LOCALTIMESTAMP, CURRENT_TIMESTAMP FROM DUAL;

-- MONTHS_BETWEEN(DATE1, DATE2) : 두 날짜의 개월 수 차이를 반환
SELECT EMP_NAME,HIRE_DATE,FLOOR(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) FROM EMPLOYEE;

--ADD_MONTHS(DATE,NUMBER) : 매개변수로 받은 날짜에, 매개변수로 받은 숫자만큼 개월수를 더해서 리턴
SELECT SYSDATE, ADD_MONTHS(SYSDATE,1) FROM DUAL;
SELECT SYSDATE, SYSDATE+3 FROM DUAL;

--NEXT_DAY(DATE,STRING[NUMBER]) : 매개변수로 받은 날짜
SELECT SYSDATE, NEXT_DAY(SYSDATE,'화요일') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE,'화') FROM DUAL;
-- 1=일요일 ~ 7=토요일
SELECT SYSDATE, NEXT_DAY(SYSDATE,2) FROM DUAL;
--LAST_DAY(DATE) : 매개변수로 받은 날짜가 속한 달의 마지막날짜를 구해서 리턴
SELECT SYSDATE, LAST_DAY(SYSDATE) FROM DUAL;
SELECT ADD_MONTHS(SYSDATE,2), LAST_DAY(ADD_MONTHS(SYSDATE,2)) FROM DUAL;
--EXTRACT : 년/월/일 따로 추출
SELECT SYSDATE FROM DUAL;
SELECT
    SYSDATE,
    EXTRACT(YEAR FROM SYSDATE),
    EXTRACT(MONTH FROM SYSDATE),
    EXTRACT(DAY FROM SYSDATE)
FROM DUAL;    
SELECT
    EMP_NAME,
    EXTRACT(YEAR FROM HIRE_DATE)||'년'||
    EXTRACT(MONTH FROM HIRE_DATE)||'월'||
    EXTRACT(DAY FROM HIRE_DATE)||'일' 입사일
FROM EMPLOYEE; 
-------------------------------------------------------------------------------

SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD/DAY') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MONTH/DD') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY"년"MM"월"DD"일" HH24"시"MI"분"SS"초"') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'FMYYYY"년"MM"월"DD"일" HH24"시"MI"분"SS"초"') FROM DUAL;--FM붙이면 앞에 0을 날려줌

SELECT 
    EMP_NAME,
    HIRE_DATE,
    TO_CHAR(HIRE_DATE,'YYYY-MM-DD(DY)') 입사일
FROM
    EMPLOYEE;
    
-- 숫자에서 문자로 변화
--0 OR 9를 통해서 숫자의 최대 갯수를 표현
-- 100 -> 000, 999
-- 변환될 숫자길이보다 포맷길이가 길어야함
SELECT 10000, TO_CHAR(10000,'000,000,000') FROM DUAL;
SELECT 10000, TO_CHAR(10000,'999,999,999') FROM DUAL;--남는공간 없애줌
SELECT 10000, TO_CHAR(10000,'999,999,999.999') FROM DUAL;
SELECT 10000, TO_CHAR(10000,'L999,999,999') FROM DUAL;--해당지역 윈도우 언어에 따라 화폐단위가 붙음
SELECT EMP_NAME, TO_CHAR(SALARY,'L999,999,999') 월급 FROM EMPLOYEE;


-- TO_DATE
SELECT TO_DATE(20220715,'YYYYMMDD') FROM DUAL;

SELECT TO_CHAR(TO_DATE(20220715,'YYYYMMDD'),'YYYY-MM-DD HH24:MI:SS') FROM DUAL;

-- EMPLOYEE 테이블에서 2000년도 이후에(2000년도 포함) 입사한 사원의 이름, 입사일
SELECT EMP_NAME, HIRE_DATE 
FROM EMPLOYEE
WHERE
EXTRACT(YEAR FROM HIRE_DATE) >=2000
;
SELECT EMP_NAME, HIRE_DATE 
FROM EMPLOYEE
WHERE
    HIRE_DATE > TO_DATE(20000101,'YYYYMMDD');
    
SELECT TO_NUMBER('10,000', '99,999') FROM DUAL;
----------------------------------------------------------------------------
--NVL : NULL처리함수
SELECT 
     EMP_NAME,
     SALARY,
     NVL(BONUS,0),
     SALARY*12 연봉,
     (SALARY+(SALARY*NVL(BONUS,0)))*12 "연봉(보너스포함)"
FROM
     EMPLOYEE;
-- DECODE 선택함수1 : 여러가지 경우에 선택할 수 있는 기능 제공
SELECT
    EMP_NAME,EMP_NO,DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여','?')성별
FROM EMPLOYEE;    
/*
switch(변수) {
        case "1" : 처리 break;
        case "2" : 처리 break;
        default :
}
*/
-- CASE : 여러가지경우 선택할 수 있는 기능제공(범위값도 가능)
SELECT
    EMP_NAME,EMP_NO,
    CASE
        WHEN SUBSTR(EMP_NO,8,1)=1 OR SUBSTR(EMP_NO,8,1)=3
        THEN '남'
        WHEN SUBSTR(EMP_NO,8,1) IN (2,4)
        THEN '여'
        ELSE '?'
    END AS 성별
FROM EMPLOYEE;    
------------------------------------------------------------------------------
--SUM : 해당 컬럼 값들의 총 합을 구하는함수
SELECT SUM(SALARY*12) FROM EMPLOYEE--그룹함수 사용할때 일반함수를 같이 사용 X
WHERE DEPT_CODE='D5';
--AVG : 해당 컬럼값들의 평균을 구하는 함수
SELECT AVG(SALARY) FROM EMPLOYEE;
SELECT AVG(NVL(BONUS,0)) FROM EMPLOYEE;
SELECT BONUS FROM EMPLOYEE;
--COUNT : 조회한 ROW수를 반환
SELECT COUNT(BONUS) FROM EMPLOYEE;
SELECT SALARY FROM EMPLOYEE;

-- 최대값, 최소값
SELECT MAX(SALARY), MIN(SALARY) FROM EMPLOYEE;
SELECT MAX(HIRE_DATE), MIN(HIRE_DATE) FROM EMPLOYEE;


--------------------------------------------------------------------------
--실습1
SELECT EMP_NAME"직원명",EMAIL"이메일",LENGTH(EMAIL)"이메일길이" FROM EMPLOYEE;

--실습2
SELECT EMP_NAME,SUBSTR(EMAIL,1,INSTR(EMAIL,'@',1,1)-1)"이메일아이디" FROM EMPLOYEE;

--실습3
SELECT EMP_NAME"직원명",SUBSTR(EMP_NO,1,2)"년생",NVL(BONUS,0)"보너스"
FROM EMPLOYEE
WHERE
EXTRACT (YEAR FROM HIRE_DATE) >=1960;

--실습4
SELECT COUNT (*)||'명'인원 FROM EMPLOYEE WHERE PHONE NOT LIKE '010%';

-- 실습5
SELECT 
      EMP_NAME"직원명",
      EXTRACT(YEAR FROM HIRE_DATE)||'년'||
      EXTRACT(MONTH FROM HIRE_DATE)||'월' 입사년월
FROM EMPLOYEE;      
      
--실습6
SELECT EMP_NAME,  RPAD(SUBSTR(EMP_NO,1,8),14,'*')"주민등록번호" FROM EMPLOYEE ;

--실습7
SELECT EMP_NAME,JOB_CODE,TO_CHAR((SALARY+(SALARY*NVL(BONUS,0)))*12,'L999,999,999') 월급 FROM EMPLOYEE;

--실습8
SELECT EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE FROM EMPLOYEE WHERE DEPT_CODE IN ('D5','D9') AND
EXTRACT(YEAR FROM HIRE_DATE) =2004;

--실습9
SELECT EMP_NAME"직원명",HIRE_DATE"입사일", FLOOR((SYSDATE-HIRE_DATE))"근무일수" FROM EMPLOYEE;

-- 실습10
SELECT 
      MAX (EXTRACT(YEAR FROM SYSDATE)-(1900+SUBSTR(EMP_NO,1,2))+1)최대나이,
      MIN (EXTRACT(YEAR FROM SYSDATE)-(1900+SUBSTR(EMP_NO,1,2))+1)최소나이
FROM EMPLOYEE;      

--실습 11  
SELECT
    EMP_NAME,DEPT_CODE,
    CASE
        WHEN SUBSTR(DEPT_CODE,2,2)IN (5,6,9)
        THEN '야근'
        WHEN SUBSTR(DEPT_CODE,2,2) IN (1,2,3,4,7,8)
        THEN '야근없음'
        ELSE '야근없음'
    END AS 야근유무
FROM EMPLOYEE ORDER BY DEPT_CODE ASC; 
--실습 11-1
SELECT
     EMP_NAME,DEPT_CODE,
     CASE
        WHEN DEPT_CODE IN ('D5','D6','D9')
        THEN '야근'
        ELSE '야근없음'
    END AS 야근유무
FROM EMPLOYEE ORDER BY DEPT_CODE ASC; 
--정렬
--ex) ORDER BY EMP_NAME ASC;오름차순
--ex) ORDER BY EMP_NAME DESC;내림차슌
--SELECT * FROM EMPLOYEE ORDER BY 2 ASC;
--SELECT EMP_NAME,DEPT_CODE FROM EMPLOYEE ORDER BY SALARY ASC;


--실습12
SELECT EMP_NAME,DEPT_CODE,
    CASE
        WHEN SUBSTR(DEPT_CODE,2,2)IN (5)
        THEN '총무부'
        WHEN SUBSTR(DEPT_CODE,2,2)IN (6)
        THEN '기획부'
        WHEN SUBSTR(DEPT_CODE,2,2)IN (9)
        THEN '영업부'
   END AS 부서명
FROM EMPLOYEE 
WHERE DEPT_CODE IN ('D5','D6','D9')
ORDER BY DEPT_CODE ASC;
--실습12-1
SELECT EMP_NAME,DEPT_CODE,
    CASE
        WHEN SUBSTR(DEPT_CODE,2,2)IN (5)
        THEN '총무부'
        WHEN DEPT_CODE = 'D6' THEN '기획부'
        WHEN DEPT_CODE = 'D9' THEN '영업부'
   END AS 부서명
FROM EMPLOYEE 
WHERE DEPT_CODE IN ('D5','D6','D9')ORDER BY DEPT_CODE ASC;


--실습13
SELECT EMP_NAME,DEPT_CODE,
        SUBSTR(EMP_NO,1,2)||'년'||
        SUBSTR(EMP_NO,3,2)||'월'||
        SUBSTR(EMP_NO,5,2)||'일' AS 생년월일,
        EXTRACT(YEAR FROM SYSDATE)-
        EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,6),'RRMMDD'))+1 AS 나이
FROM EMPLOYEE
WHERE EMP_ID NOT IN (200,201,214);


--실습 14
SELECT
    COUNT (DECODE (EXTRACT(YEAR FROM HIRE_DATE),1998,1)) AS "1998년",
    COUNT (DECODE (EXTRACT(YEAR FROM HIRE_DATE),1999,1)) AS "1999년",
    SUM(DECODE (EXTRACT(YEAR FROM HIRE_DATE),2000,1,0)) AS "2000년",
    SUM(DECODE (EXTRACT(YEAR FROM HIRE_DATE),2001,1,0)) AS "2001년",
    SUM(DECODE (EXTRACT(YEAR FROM HIRE_DATE),2002,1,0)) AS "2002년",
    SUM(DECODE (EXTRACT(YEAR FROM HIRE_DATE),2003,1,0)) AS "2003년",
    SUM(DECODE (EXTRACT(YEAR FROM HIRE_DATE),2004,1,0)) AS "2004년",
    COUNT(*) 전체
FROM EMPLOYEE;

------------------------------------------------------------------------------

SELECT DEPT_CODE, SUM(SALARY), AVG(SALARY), COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT 
    DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별,
    SUM(SALARY),
    COUNT(*)
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D1','D2','D3')
GROUP BY DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여')
ORDER BY 3 DESC;

SELECT
    DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY)) > 3000000;

--------------------------------------------------------------------
--1. EMPLOYEE테이블에서 J1직급 제외(JOB_CODE)
-- 직급, 직급별 사원수, 직급별 평균급여 출력
-- J2      3          3566600
SELECT 
    JOB_CODE"직급",COUNT(*)사원수, FLOOR(AVG(SALARY))평균급여
FROM EMPLOYEE
WHERE JOB_CODE NOT IN 'J1'
GROUP BY JOB_CODE;    


SELECT * FROM EMPLOYEE;
--2. EMPLOYEE테이블에서 J1직급 제외(JOB_CODE)
--입사 년도별 인원수를 조회해서 입사년기준으로 오름차순 정렬
SELECT EXTRACT(YEAR FROM HIRE_DATE), COUNT(*)
FROM EMPLOYEE
WHERE JOB_CODE !='J1'
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
ORDER BY 1;
------------------------------------------------------------------------------

-- 부서별 성별 인원수
-- D1 남 2
-- D1 여 1
SELECT DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),1,'남',2,'여') AS 성별,
COUNT(*) 인원수
FROM EMPLOYEE
GROUP BY DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),1,'남',2,'여')
ORDER BY 1;

-------------------------------------------------------------------------------
--JOIN


--1. ORACLE전용구문
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;
-- 2. ANSI 표준구문
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT EMP_NAME, JOB_CODE FROM EMPLOYEE;
SELECT * FROM JOB;
--1.ORACLE구문(비교하려는 컬럼이름이 같은경우)
SELECT EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;
-- 2. ANSI 표준구문(비교하려는 컬럼이름이 같은경우)
SELECT EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);

SELECT EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE);--USING두개를 한번에 합쳐줌

-- INNER JOIN (비교구문ㅇ과 일치하는 데이터가 없으면 JOIN결과에서 제외)
--DEPT_CODE가 NULL인 직원은 제외됨
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

-- OUTER JOIN
-- LEFT JOIN (둘중 왼쪽에 있는 데이터는 무조건 포함)중요!!!!!!!!!!
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);
-- RIGHT JOIN (둘중 오른쪽에 있는 데이터는 무조건 포함)
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE RIGHT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);
--FULL JOIN(양쪽에 있는 데이터는 무조건 포함)
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE FULL JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--CROSS JOIN(조건식이 들어가면 안됨)(전체적으로 곱해줌)
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE 
CROSS JOIN DEPARTMENT;

SELECT * FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, MANAGER_ID FROM EMPLOYEE
WHERE EMP_ID = MANAGER_ID;

--EMPLOYEE E1(직원정보용), EMPLOYEE E2(관리자정보용)--셀프조인
SELECT E1.EMP_ID, E1.EMP_NAME, E1.MANAGER_ID, E2.EMP_NAME AS MANAGER_NAME
FROM EMPLOYEE E1
LEFT JOIN EMPLOYEE E2 ON (E1.MANAGER_ID = E2.EMP_ID)
ORDER BY 1;

--EMPLOYEE, DEPARTMENT

SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

SELECT EMP_NAME, DEPT_TITLE, NATIONAL_CODE--다중조인
FROM EMPLOYEE 
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)--코드명이 다르면 ON이 온다
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE DEPT_CODE IN ('D9','D6');--조건문 WHERE는 조인 다음에 나옴

SELECT * FROM JOB;

SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE);

--총무부에서 근무하는 직원의 이름, 부서코드, 부서명, 급여를 조회
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_CODE = 'D9';

--실습1: 주민번호가 1970년대생이면서 성별이 여자이고, 성이 전씨인 직원들의 
--사원명, 주민번호, 부서명, 직급명을 조회하시오.
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, EMP_NO, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
--WHERE EMP_NAME LIKE '전__' AND 69 < SUBSTR(EMP_NO,1,2) AND SUBSTR(EMP_NO,1,2) <80;
WHERE EMP_NO LIKE '7%-2%' AND EMP_NAME LIKE '전%';


--실습2 : 이름에 '형'자가 들어가는 직원들의 사번, 사원명, 부서명을 조회하시오.
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE EMP_NAME LIKE '%형%';

--실습3 : 해외 영업부에 근무하는 사원명, 직급명, 부서코드, 부서명을 조회.
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, JOB_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
WHERE DEPT_TITLE LIKE '%해외영업%'ORDER BY JOB_CODE ASC;

--실습4: 보너스포인트를 받는 직원들의 사원명, 보너스포인트, 부서명, 근무지역명을 조회.
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, BONUS, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
LEFT JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE BONUS IS NOT NULL;

--실습5: 부서코드가 D2인 직원들의 사원명, 직급명, 부서명, 근무지역명을 조회.
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
LEFT JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE DEPT_CODE = 'D2';
--실습6: 한국(KO)과 일본(JP)에 근무하는 직원들의 사원명, 부서명, 지역명, 국가명을 조회.
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL USING (NATIONAL_CODE)
WHERE NATIONAL_NAME IN ('한국','일본');
--실습7: 같은 부서에 근무하는 직원들의 사원명, 부서명, 동료이름을 조회하시오.(SELF JOIN 사용)
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT E1.EMP_NAME, DEPT_TITLE, E2.EMP_NAME AS 동료이름
FROM EMPLOYEE E1
JOIN DEPARTMENT ON (E1.DEPT_CODE = DEPT_ID)
LEFT JOIN EMPLOYEE E2 ON (E1.DEPT_CODE = E2.DEPT_CODE)
WHERE E1.EMP_NAME != E2.EMP_NAME
ORDER BY 1;

--실습8: 보너스포인트가 없는 직원들 중에서 
--직급이 차장과 사원인 직원들의 사원명, 직급명, 급여를 조회. 단, JOIN과 IN을 사용할것
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME"사원명", JOB_NAME"직급명", SALARY"급여"
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE JOB_NAME IN ('차장', '사원') AND BONUS IS NULL;--NULL 체크할때는 IS,IS NOT


-------------------------------------------------------
--SET OPERATOR
--집합연산자(SET OPERATOR)-UNION
--컬럼이 동일해랴함
--두 조회결과를 하나로 합치면서 중복값제거, 첫번째 컬럼으로 정렬

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION--합집합,첫번째코드로 오름차순까지해줌
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

--중복된 데이터 제거하지 않음,합치고 정렬을 하진않음
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL--
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

--두 SELECT문에서 공통된부분만 추출(교집합)
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT--
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

--첫번째 조회문에서 두번째 조회문과 겹치는 부분을 제거
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;


-----------------------------------------------------------------
--SUBQUERY
--단일행 서브쿼리
--전직원의 평균급여보다 많은 급여를 받는 직원의 사번, 이름, 급여조회
--1.전직원의 평균급여를 조회
SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE;
--2. 1에서 조회된 결과를 이용하여 쿼리문작성
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE);


--전지연 직원의 관리자 이름을 출력
--1.전지연 직원의 관리자 사번(MANAGER_ID) 조회
SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME = '전지연';
--2. 1의 조회결과로 관리자 이름 출력-->SUBQUERY
SELECT EMP_NAME FROM EMPLOYEE
WHERE EMP_ID = (SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME = '전지연');
--SELF JOIN
SELECT E2.EMP_NAME
FROM EMPLOYEE E1
JOIN EMPLOYEE E2 ON (EL.MANAGER_ID = E2.EMP_ID)
WHERE E1.EMP_NAME = '전지연'



--1.윤은해와 급여가 같은 사원들의 사원번호,이름,급여를 출력
--단, 윤은해는 출력X
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;

SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '윤은해';

SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '윤은해')AND EMP_NAME != '윤은해';

--2. EMPLOYEE 테이블에서 급여가 가장 많은사람과, 가장적은 사람의
--사번,이름,급여출력
SELECT MAX(SALARY) FROM EMPLOYEE;
SELECT MIN(SALARY) FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE)
OR SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);
--SALARY IN ((SELECT MAX(SALARY) FROM EMPLOYEE), (SELECT MIN(SALARY) FROM EMPLOYEE));

--3. D1,D2부서에서 근무하는 사원들 중 급여가 , D5부서 직원들의 
--평균급여보다 많은 사람들의 이름,부서코드,급여 출력
SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN ('D1','D2');
SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D5'

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D1','D2') AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D5');
--------------------------------------------------------------
--20220720 시험범위
-----------------
----------------------------------------------
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;
--1.
SELECT * FROM EMPLOYEE 
WHERE BONUS IS NULL 
AND MANAGER_ID IS NOT NULL;
--2.
SELECT EMP_NAME, EMP_NO,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D9' OR DEPT_CODE = 'D6' AND SALARY > 3000000
AND BONUS IS NULL;

SELECT EMP_NAME, EMP_NO,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D9','D6') 
AND SALARY >= 3000000 
AND BONUS IS NULL;
--3.

SELECT EMP_ID, EMP_NAME, E1.JOB_CODE, JOB_NAME
FROM EMPLOYEE E1
JOIN JOB J ON (E1.JOB_CODE = J.JOB_CODE)
WHERE SALARY >= 3000000;
------------------------------------------------------------------------
----------------20220720시험문제 끝---
---------------------------------------


--다중행 서브쿼리
--각 부서별 최ㅐ고급여를 받는 직원의 이름, 부서코드, 급여출력
SELECT MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE;

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY IN (SELECT MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE);
--비교값 > ANY()  --> 최소값보다 크면
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > ANY(SELECT MAX(SALARY)--ANY연산자
FROM EMPLOYEE GROUP BY DEPT_CODE);
--비교값 < ANY()  --> 최대값보다 작으면
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY < ANY(SELECT MAX(SALARY)--ANY연산자
FROM EMPLOYEE GROUP BY DEPT_CODE);
--비교값 = ANY()  --> IN과 같은효과
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY = ANY(SELECT MAX(SALARY)--ANY연산자
FROM EMPLOYEE GROUP BY DEPT_CODE);

--비교값 > ALL()  --> 최대값보다 크면
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > ALL(SELECT MAX(SALARY)--ALL연산자
FROM EMPLOYEE GROUP BY DEPT_CODE);
--비교값 < ALL()  --> 최소값보다 작으면
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY < ALL(SELECT MAX(SALARY)--ALL연산자
FROM EMPLOYEE GROUP BY DEPT_CODE);

--다중열 SUBQUERY
-- 퇴사한 직원의 부서, 직급을 조회 ENT_YN = 'Y'
--퇴사한 직원과 같은 부서, 같은 직급에 해당하는 사원 이름,부서,직급코드 출력
SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN = 'Y';

SELECT EMP_NAME, DEPT_CODE, JOB_CODE
FROM EMPLOYEE
WHERE 
(DEPT_CODE, JOB_CODE) IN (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN = 'Y');
--DEPT_CODE = 'D8' AND JOB_CODE = 'J6';


--상관쿼리(상호연관 서브쿼리)
--메인 쿼리값을 서브쿼리에 주고 서브쿼리를 수행한 후 다시 메인쿼리를 수행
SELECT EMP_ID, EMP_NAME, DEPT_CODE, MANAGER_ID
FROM EMPLOYEE E1
WHERE EXISTS (SELECT EMP_ID FROM EMPLOYEE E2 WHERE E1.MANAGER_ID = E2.EMP_ID);
SELECT EMP_ID, MANAGER_ID FROM EMPLOYEE;

--스칼라 서브쿼리 : 상호연관 서브쿼리면서 결과값이 1개인 서브쿼리
--스칼라 서브쿼리에서 ( SELECT절 사용)
--모든사원의 사번, 이름, 관리자번호, 관리자이름 조회
SELECT EMP_ID, EMP_NAME, MANAGER_ID,
(SELECT E2.EMP_NAME FROM EMPLOYEE E2 
WHERE E2.EMP_ID = E1.MANAGER_ID) AS 관리자명
FROM EMPLOYEE E1;

--사원명,부서코드,소속부서의 평균임금을 스칼라서브쿼리로 출력
SELECT EMP_NAME, DEPT_CODE, 
FLOOR((SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E2.DEPT_CODE = E1.DEPT_CODE)
)AS 평균임금
FROM EMPLOYEE E1;

--인라인 뷰
--뷰 : 가상의 테이블
--인라인뷰: FROM에서 사용하는 서브쿼리(상호연관은 아님)
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY FROM EMPLOYEE; 

SELECT *
FROM
(SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY FROM EMPLOYEE);

--TOP-N 분석
--회사에서 급여가 가장 높은 직원 5명의 이름, 부서코드, 급여출력
SELECT ROWNUM, EMP_NAME, DEPT_CODE, SALARY FROM (SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM < 6;

SELECT SALARY FROM EMPLOYEE ORDER BY 1 DESC;

--------19/19/21
SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) FROM EMPLOYEE;
--------19/19/20
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER(ORDER BY SALARY DESC) FROM EMPLOYEE;
--------19/20/21
SELECT EMP_NAME, SALARY, ROW_NUMBER() OVER(ORDER BY SALARY DESC) FROM EMPLOYEE;
--------
---------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
SELECT * FROM EMPLOYEE;
--전 직원의 이름, 부서명, 직급명, 급여 출력
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM SAL_GRADE;
--1)JOIN
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE  = DEPT_ID)
LEFT JOIN JOB USING (JOB_CODE);
--2)SUBQUERY
SELECT 
    EMP_NAME, 
    (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_ID=E.DEPT_CODE)AS DEPT_TITLE, 
    (SELECT JOB_NAME FROM JOB J WHERE J.JOB_CODE=E.JOB_CODE)AS JOB_NAME, 
    SALARY
FROM EMPLOYEE E;    

----
--SUBQUERY로 테이블을 생성하는 경우는 컬럼이름,데이터타입,값 까지는 복사가 됨,
--대신 제약조건은  NOT NULL만 복사가능
CREATE TABLE EMP_COPY
AS--AS를 넣어주면 알 SELECT문을 EMP_COPY에 넣어줌/ AS 핵심!!!
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE  = DEPT_ID)
LEFT JOIN JOB USING (JOB_CODE);

SELECT * FROM EMP_COPY;

CREATE TABLE EMP_COPY2
AS
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE WHERE 1=0;--FALSE를 만들어서 다 안나오게
SELECT * FROM EMP_COPY2;

CREATE TABLE EMP_COPY3
AS
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE WHERE 1=0;

CREATE TABLE EMP_COPY4
AS
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE WHERE 1=0;

INSERT ALL
INTO EMP_COPY3 VALUES(EMP_NAME, DEPT_CODE, SALARY)
INTO EMP_COPY4 VALUES(EMP_NAME, JOB_CODE, SALARY)
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY FROM EMPLOYEE;
SELECT * FROM EMP_COPY3;
SELECT * FROM EMP_COPY4;

--ALTER : 데이터베이스 객체 정보를 수정
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT;
SELECT * FROM DEPT_COPY;
--테이블 컬럼을 추가
ALTER TABLE DEPT_COPY
ADD (KNAME VARCHAR2(20));

ALTER TABLE DEPT_COPY
ADD (HNAME VARCHAR2(20) DEFAULT 'HI');
--테이블 컬럼 자료형 변경
DESC DEPT_COPY;
ALTER TABLE DEPT_COPY
MODIFY DEPT_TITLE VARCHAR2(50);
--제약조건 확인
SELECT 
    UC.CONSTRAINT_NAME,
    UC.CONSTRAINT_TYPE,
    UCC.COLUMN_NAME,
    UC.SEARCH_CONDITION
FROM USER_CONSTRAINTS UC
JOIN USER_CONS_COLUMNS UCC
ON (UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
WHERE UC.TABLE_NAME='DEPT_COPY';--'DEPT_COPY'은 소문자로 적어놨어도 여기서는 무조건 대문자로 적어줘야함

--제약조건 추가
SELECT * FROM DEPT_COPY;
ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_ID_PK PRIMARY KEY(DEPT_ID); --제약조건 추가란

ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_TITLE_UNQ UNIQUE(DEPT_TITLE);--UNIQUE추가
--NOT NULL 제약조건은 추가시 ADD가 아니라 MODIFY
ALTER TABLE DEPT_COPY
MODIFY HNAME CONSTRAINT DCOPY_HNAME_NN NOT NULL;

--제약조건 제거
ALTER TABLE DEPT_COPY
DROP CONSTRAINT DCOPY_ID_PK;

ALTER TABLE DEPT_COPY
DROP CONSTRAINT DCOPY_TITLE_UNQ;

ALTER TABLE DEPT_COPY
MODIFY HNAME NULL; --위와는 스타일이 다름
-------
--한번에 추가하기
ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_ID_PK PRIMARY KEY(DEPT_ID)
ADD CONSTRAINT DCOPY_TITLE_UNQ UNIQUE(DEPT_TITLE)
MODIFY HNAME CONSTRAINT DCOPY_HNAME_NN NOT NULL;

--한번에 제거하기
ALTER TABLE DEPT_COPY
DROP CONSTRAINT DCOPY_ID_PK
DROP CONSTRAINT DCOPY_TITLE_UNQ
MODIFY HNAME NULL;

--컬럼삭제
ALTER TABLE DEPT_COPY
DROP COLUMN KNAME;
SELECT * FROM DEPT_COPY;

--컬럼이름수정, 제약조건이름수정, 테이블이름 수정
--HNAME -> KNAME
ALTER TABLE DEPT_COPY
RENAME COLUMN HNAME TO KHNAME;
DESC DEPT_COPY;
-- SYS_C007056 -> DEPT_ID_NN//제약조건이름 변경
ALTER TABLE DEPT_COPY
RENAME CONSTRAINT SYS_C007081 TO DEPT_ID_NN;--/제약조건은 COLUMN대신 CONSTRAINT사용
-- DEPT_COPY -> ALTER_TEST//테이블이름변경
ALTER TABLE DEPT_COPY
RENAME TO ALTER_TEST;

SELECT * FROM ALTER_TEST;

-- TRUNCATE : 테이블 전체 행 삭제
--DELETE에서 WHERE을 사용하지 않은것과 차이점
--1) TRUNCATE가 수행속도가 빠름
--2) 상황에따라서 DELECT는 데이터복구가 가능, TRUNCATE 데이터복구 불가능
TRUNCATE TABLE ALTER_TEST;

--DROP : 데이터베이스 객체 삭제//복구 불가능
DROP TABLE ALTER_TEST;

--실습1
DROP TABLE RUNNINGMAN;
CREATE TABLE RUNNINGMAN(
   NO    NUMBER PRIMARY KEY,
   ID    VARCHAR2(20)   UNIQUE,
   PASS  VARCHAR2(20) NOT NULL,
   NAME  VARCHAR2(20) NOT NULL,
   NICKNAME VARCHAR2(20) UNIQUE,
   GENDER  CHAR(1)CHECK (GENDER IN ('M', 'F')),
   TEL   VARCHAR2(20) DEFAULT '010-0000-0000',
   ADDRESS  VARCHAR2(90)
);
INSERT INTO RUNNINGMAN 
VALUES(1,'muhan','1234','유재석','못생긴형','M','010-4958-2333','압구정');
INSERT INTO RUNNINGMAN 
VALUES(2,'bignose','4444','지석진','지는해','M',DEFAULT,'서울');
INSERT INTO RUNNINGMAN 
VALUES(3,'tiger','6658','김종국','안꼬','M','010-6674-8986','안양');
INSERT INTO RUNNINGMAN 
VALUES(4,'haha','5356','하하','신분세탁','M','010-8997-1122','서래마을');
INSERT INTO RUNNINGMAN 
VALUES(5,'ace','5555','송지효','천성임','F',DEFAULT,'서울시');
INSERT INTO RUNNINGMAN 
VALUES(6,'girrafe','6658','이광수','중기친구','M','010-2378-9991','남양주');
INSERT INTO RUNNINGMAN 
VALUES(7,'ssapssap','5356','양세찬','김종국팬','M','010-1215-7777','동두천');
INSERT INTO RUNNINGMAN 
VALUES(8,'doli','5555','전소민','전두릅','F',DEFAULT,'일산');

UPDATE RUNNINGMAN SET PASS = '9999' WHERE NICKNAME='중기친구';

UPDATE RUNNINGMAN SET TEL = '없음' WHERE NO IN(2,5,8);

DELETE FROM RUNNINGMAN WHERE NAME='유재석';

SELECT * FROM RUNNINGMAN;
DESC RUNNINGMAN;
------------------------------------------------------------------------------------
--DML
--회원(이름,나이,주소,성별,아이디,패스워드,가입일)
CREATE TABLE MEMBER_TBL(
     MEMBER_ID   VARCHAR2(20),         --아이디
     MEMBER_PW   VARCHAR2(30),         --비밀번호
     MEMBER_NAME   VARCHAR2(20),       --이름
     MEMBER_AGE    NUMBER,             --나이
     ADDRESS     VARCHAR(500),         --주소
     GENDER     CHAR(6),               --성별
     ENROLL_DATE  DATE                 --가입일
 );    
SELECT * FROM MEMBER_TBL;
 --INSERT : 테이블에 데이터를 삽입하는 구문
 -- ->ROW수가 증가한다.
 -- 1) INSERT INTO 테이블이름 (컬럼이름1,컬럼이름2...) VALUES(값1, 값2 .....);
INSERT INTO MEMBER_TBL(MEMBER_ID, MEMBER_PW, MEMBER_NAME, 
                        MEMBER_AGE, ADDRESS,GENDER,ENROLL_DATE)
             VALUES('USER01', '1234', '유저1', 20, '서울시 영등포구 당산동', '남자',sysdate);           
             
INSERT INTO MEMBER_TBL(MEMBER_NAME, MEMBER_AGE, ADDRESS, GENDER,
                        MEMBER_ID, MEMBER_PW,ENROLL_DATE)
                 VALUES('유저2',30,'서울시 영등포구','여자','user02','11111', sysdate);

INSERT INTO MEMBER_TBL(MEMBER_ID, MEMBER_PW, MEMBER_NAME)
                 VALUES('user03','33333','유저3');

INSERT INTO MEMBER_TBL(MEMBER_NAME, MEMBER_AGE, GENDER)
                VALUES('유저4',22,'남자');
--2) INSERT INTO 테이블명 VALUES(값1,값2,값3....);
--모든 컬럼의 값을 테이블의 컬럼순서대로 모두 입력해야함
INSERT INTO MEMBER_TBL VALUES('user05','5555','유저5',40,'서울시','여자',SYSDATE);
INSERT INTO MEMBER_TBL VALUES('user06','6666','유저6',NULL,NULL,NULL,NULL);

UPDATE MEMBER_TBL SET MEMBER_AGE=50 WHERE MEMBER_ID='user03';
SELECT * FROM MEMBER_TBL;      
------------------------------------------------------------------
CREATE TABLE TEST_USER_TBL(
     USER_NO    NUMBER,             --회원번호
     JOIN_DATE  DATE,               --가입일
     USER_ID    VARCHAR2(30),       --아이디
     PASSWORD   VARCHAR2(20),       --비밀번호
     NICKNAME   VARCHAR2(20),       --별명
     PHONE      CHAR(13),           --전화번호(010-0000-0000 형식)
     AGE        NUMBER              --나이
 );    
 SELECT * FROM TEST_USER_TBL;
 
INSERT INTO TEST_USER_TBL(USER_NO,JOIN_DATE,USER_ID,PASSWORD,NICKNAME,PHONE, AGE)
             VALUES(01, sysdate, '유저1', '1111', '일일', '010-1234-1234' ,20 );
INSERT INTO TEST_USER_TBL(USER_NO,JOIN_DATE,USER_ID,PASSWORD,NICKNAME,PHONE, AGE)
             VALUES(02, sysdate, '유저2', '2222', '이이', '010-1234-4567' ,30 );
INSERT INTO TEST_USER_TBL(USER_NO,JOIN_DATE,USER_ID,PASSWORD,NICKNAME,PHONE, AGE)
             VALUES(03, sysdate, '유저3', '3333', '삼삼', '010-1234-4321' ,40 );
INSERT INTO TEST_USER_TBL(USER_NO,JOIN_DATE,USER_ID,PASSWORD,NICKNAME,PHONE, AGE)
             VALUES(04, sysdate, '유저4', '4444', '사사', '010-1234-5678' ,50 );
INSERT INTO TEST_USER_TBL(USER_NO,JOIN_DATE,USER_ID,PASSWORD,NICKNAME,PHONE, AGE)
             VALUES(05, sysdate, '유저5', '5555', '오오', '010-1234-6789' ,60 ); 
             
INSERT INTO TEST_USER_TBL values(06, sysdate, '유저6', '6666', '육육', '010-1234-9876' ,70 );
INSERT INTO TEST_USER_TBL values(07, sysdate, '유저7', '7777', '칠칠', '010-2345-9876' ,80 ); 
INSERT INTO TEST_USER_TBL values(08, sysdate, '유저8', '8888', '팔팔', '010-3456-9876' ,90 ); 
INSERT INTO TEST_USER_TBL values(09, sysdate, '유저9', '9999', '구구', '010-4567-9876' ,100 ); 
INSERT INTO TEST_USER_TBL values(10, sysdate, '유저10', '0000', '텐텐', '010-5678-9876' ,110 ); 

UPDATE TEST_USER_TBL
SET NICKNAME='칠순잔치',PHONE='010-7777-7777'
WHERE USER_NO=07;

DELETE FROM TEST_USER_TBL WHERE USER_ID='유저6';
-------------------------------------------------------
--수정
-- UPDATE 테이블이름 SET 수정할컬럼이름 = 수정값, 수정할컬럼이름=수정값 WHERE 조건
UPDATE MEMBER_TBL SET MEMBER_AGE=50 WHERE MEMBER_ID='user03';
UPDATE MEMBER_TBL
SET ADDRESS='경기도', GENDER='남자',ENROLL_DATE=SYSDATE-1
WHERE MEMBER_ID='user03';--행35

UPDATE MEMBER_TBL
SET MEMBER_ID='user04', MEMBER_PW='4444', ADDRESS='부산시',ENROLL_DATE=SYSDATE-3
WHERE MEMBER_NAME='유저4';
SELECT * FROM MEMBER_TBL; 
------------------------------------------
--삭제
--DELETE : ROW수 감소
--DELETE FROM 테이블명 WHERE 조건
DELETE FROM MEMBER_TBL WHERE MEMBER_ID='user06';

COMMIT;

--------------------------------------------------------------------------
DROP TABLE USER_TBL;
CREATE TABLE USER_TBL(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE NOT NULL,
    USER_PW VARCHAR(30)  NOT NULL
);
INSERT INTO USER_TBL VALUES(1,'user01','1234');
INSERT INTO USER_TBL VALUES(2,'user02','2222');
INSERT INTO USER_TBL VALUES(3,'user03','3333');
COMMIT;
INSERT INTO USER_TBL VALUES(4,'user04','4444');
INSERT INTO USER_TBL VALUES(5,'user05','5555');
INSERT INTO USER_TBL VALUES(6,'user06','4444');
INSERT INTO USER_TBL VALUES(7,'user07','4444');
ROLLBACK;
UPDATE USER_TBL SET USER_PW='5555' WHERE USER_NO=5;
SELECT * FROM USER_TBL;
SAVEPOINT SP1;
ROLLBACK TO SP1;

--VIEW 생성
CREATE OR REPLACE VIEW EMP_VIEW--얕은복사개념
AS
SELECT EMP_ID, EMP_NAME, PHONE, SALARY FROM EMPLOYEE;

CREATE TABLE EMP_COPY5--깊은복사개념
AS
SELECT EMP_ID, EMP_NAME, PHONE, SALARY FROM EMPLOYEE;

SELECT * FROM EMPLOYEE;
SELECT * FROM EMP_VIEW;
SELECT * FROM EMP_COPY5;
UPDATE EMP_COPY5 SET SALARY = 7000000 WHERE EMP_ID=200;
UPDATE EMP_VIEW SET SALARY = 9000000 WHERE EMP_ID=200;

--시퀀스 : 자동번호생성기
/*
CREATE SEQUENCE 시퀀스이름
CREATE SEQUENCE 시퀀스이름; --1부터시작해서 1씩 증가하는 시퀀스 생성

CREATE SEQUENCE 시퀀스이름
START WITH 숫자      --시퀀스 시작번호 설정
INCREMENT BY 숫자    --다음숫자 발생시 증가폭
MAXVALUE 숫자        --시퀀스가 발생시키는 숫자의 최대값
[CYCLE | NOCYCLE]   --CYCLE : 최대값도달시 이후에 다시 START부터 시작/NOCYCLE:에러발생
[CACHE | NOCACHE]   -- 시퀀스값을 메모리에서 처리할지 결정
*/
CREATE SEQUENCE USER_NO_SEQ
START WITH 10
INCREMENT BY 10
MAXVALUE 100
NOCYCLE
NOCACHE;
DROP SEQUENCE USER_NO_SEQ;

SELECT USER_NO_SEQ.NEXTVAL FROM DUAL;
SELECT USER_NO_SEQ.CURRVAL FROM DUAL;
INSERT INTO USER_TBL VALUES(USER_NO_SEQ.NEXTVAL,'user10','4444');
SELECT * FROM USER_TBL;
--1)NEXTVAL하기전에 CURRVAL실행 하면안됨


--시퀀스 생성
--시퀀스 이름: SEQ_TEST_NO
--시작번호 : 1, 증가값 :5, 최대값 100, NOCYCLE, NOCACHA
CREATE SEQUENCE SEQ_TEST_NO
START WITH 1
INCREMENT BY 5
MAXVALUE 100
NOCYCLE
NOCACHE;

ALTER SEQUENCE SEQ_TEST_NO--수정문구 ALTER사용
INCREMENT BY 10
MAXVALUE 100
NOCYCLE
NOCACHE;

SELECT SEQ_TEST_NO.NEXTVAL FROM DUAL;
SELECT SEQ_TEST_NO.CURRVAL FROM DUAL;
INSERT INTO USER_TBL VALUES(SEQ_TEST_NO.NEXTVAL,'user15','5555');
DROP SEQUENCE SEQ_TEST_NO;
SELECT * FROM USER_TBL;
-------------------------------------------
CREATE TABLE KH_MEMBER(
   MEMBER_ID   NUMBER,
   MEMBER_NAME  VARCHAR2(20),
   MEMBER_AGE   NUMBER,
   MEMBER_JOIN_COM  NUMBER
);
--INSERT INTO KH_MEMBER VALUES(1,'user01',20,1);
--INSERT INTO KH_MEMBER VALUES(2,'user02',21,2);
--INSERT INTO KH_MEMBER VALUES(3,'user03',22,3);
--INSERT INTO KH_MEMBER VALUES(4,'user04',23,4);

CREATE SEQUENCE MEMBER_ID
START WITH 500
INCREMENT BY 10
MAXVALUE 10000
NOCYCLE
NOCACHE;
CREATE SEQUENCE MEMBER_JOIN_COM
START WITH 1
INCREMENT BY 1
MAXVALUE 10000
NOCYCLE
NOCACHE;

INSERT INTO KH_MEMBER VALUES(MEMBER_ID.NEXTVAL,'고길동',24,MEMBER_JOIN_COM.NEXTVAL);
SELECT * FROM KH_MEMBER;

------------------
--INDEX
CREATE INDEX EMP_IDX
ON 
EMPLOYEE(EMP_NAME, EMP_NO, HIRE_DATE);
DROP INDEX EMP_IDX;
SELECT EMP_NAME, EMP_NO, HIRE_DATE FROM EMPLOYEE;


--SYNONYM
--비공개동의어// 공개동의어 설명은 admin1에 있음
SELECT * FROM EMPLOYEE;
SELECT * FROM EMP;
SELECT * FROM DEPT;
CREATE SYNONYM EMP FOR EMPLOYEE;
DROP SYNONYM EMP;
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
/*
PL/SQL :Procedural Language extention to SQL
->오라클 자체에 내장되어 있는 절차적 언어
-> SQL 단점을 보완하여 문장내 변수정의 ,조건처리, 반복처리 등을 지원
PL/SQL 유형
1. 익명블록
    -> 이름이 없는 블록, 간단한 블록 수행 시 사용
2. 프로시저(리턴이 없는 메소드)
   -> 지정된 특정 처리를 실행하는 서브프로그램
3. 함수(리턴이 있는 메소드)
   -> 프로시저와 거의 동일

PL/SQL 문법 구조

DECLARE(선언부)
   -> 변수 또는 상수를 선언하는 부분
   -> 변수를 사용하지 않는 경우 생략가능
BEGIN(실행부)
   -> 제어문,반복문,함수정의 등 로직을 기술
   -> 반드시 작성
EXCEPTION(예외처리부)
   -> 예외상황 발생시 해결하기 위한 구문 작성
   -> 생략가능
END;(블록종료)
/(PL/SQL 실행 및 종료)
*/
SET SERVEROUTPUT ON;
--

BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO ORACLE');
END;
/
--------
--------
DECLARE
    ID       NUMBER;
    NAME     VARCHAR2(20);
BEGIN
    SELECT EMP_ID, EMP_NAME
    INTO ID,NAME
    FROM EMPLOYEE
    WHERE EMP_NAME='선동일';
    DBMS_OUTPUT.PUT_LINE('사번 : '||ID);
    DBMS_OUTPUT.PUT_LINE('이름 : '||NAME);
END;
/
------------------------
DECLARE
    NAME     VARCHAR2(20);
    D_CODE   VARCHAR2(20);
    J_CODE   VARCHAR2(20);
BEGIN
    SELECT EMP_NAME, DEPT_CODE, JOB_CODE
    INTO NAME, D_CODE, J_CODE
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('이름 : '||NAME);
    DBMS_OUTPUT.PUT_LINE('부서코드 : '||D_CODE);
    DBMS_OUTPUT.PUT_LINE('직급코드 : '||J_CODE);
EXCEPTION
    WHEN NO_DATA_FOUND
    THEN DBMS_OUTPUT.PUT_LINE('데이터가 없습니다.');
END;
/
-------------------------
--사원번호입력시
-- 이름,부서며으 직급명이 출력되도록 익명블록작성
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;

DECLARE
   NAME     VARCHAR2(20);
   D_TITLE   VARCHAR2(20);
   J_NAME   VARCHAR2(20);
BEGIN
   SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
   INTO NAME, D_TITLE, J_NAME
   FROM EMPLOYEE
   JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
   JOIN JOB USING (JOB_CODE)
   WHERE EMP_ID='&사원';
   DBMS_OUTPUT.PUT_LINE('이름 : '||NAME);
   DBMS_OUTPUT.PUT_LINE('부서명 : '||D_TITLE);
   DBMS_OUTPUT.PUT_LINE('직급명 : '||J_NAME);
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN DBMS_OUTPUT.PUT_LINE('데이터가 없습니다.');
END;
/
------
------
/*
PL/SQL의 변수 선언 및 대입
변수이름  [CONSTANT] 자료형 [:= 초기값];                 /////[대괄호는 생략가능]
DECLARE
   NO   CONSTANT NUM := 10;  --상수인 경우 변수선언시 반드시 초기화
   NAME   VARCHAR2(20);
   TEST   VATCHAR2(30) := 'TEST문구';
*/
DECLARE
   NAME    VARCHAR2(20) :='이윤수';
   NUM     NUMBER;
   NUM1    CONSTANT NUMBER := 1;
BEGIN
   DBMS_OUTPUT.PUT_LINE(NAME);
   NAME := '변경이름';
   DBMS_OUTPUT.PUT_LINE(NAME);
END;
/
-----------
-----------
DECLARE
   NAME    EMPLOYEE.EMP_NAME%TYPE;
   D_NAME  DEPARTMENT.DEPT_TITLE%TYPE;
   J_NAME  JOB.JOB_NAME%TYPE;
BEGIN
   SELECT EMP_NAME,DEPT_TITLE, JOB_NAME
   INTO NAME, D_NAME, J_NAME
   FROM EMPLOYEE
   LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
   LEFT JOIN JOB USING (JOB_CODE)
   WHERE EMP_ID='&사번';
   DBMS_OUTPUT.PUT_LINE('이름 : '||NAME);
   DBMS_OUTPUT.PUT_LINE('부서명 : '||D_NAME);
   DBMS_OUTPUT.PUT_LINE('직급명 : '||J_NAME);
END;
/
-- 사번을 입력하면 해당 사원의 이름, 주민번호, 이메일, 부서코드, 급여를 출력
--MYROW : 동일한 변수들끼리 한번에 묶어주는 코드
DECLARE
   MYROW   EMPLOYEE%ROWTYPE;
BEGIN
   SELECT EMP_NAME,EMP_NO,EMAIL,DEPT_CODE,SALARY
   INTO MYROW.EMP_NAME,MYROW.EMP_NO,MYROW.EMAIL,MYROW.DEPT_CODE,MYROW.SALARY
   FROM EMPLOYEE
   WHERE EMP_ID='&사번';
   DBMS_OUTPUT.PUT_LINE('이름 : '||MYROW.EMP_NAME);
   DBMS_OUTPUT.PUT_LINE('주민등록번호 : '||MYROW.EMP_NO);
   DBMS_OUTPUT.PUT_LINE('이메일 : '||MYROW.EMAIL);
   DBMS_OUTPUT.PUT_LINE('부서코드 : '||MYROW.DEPT_CODE);
   DBMS_OUTPUT.PUT_LINE('급여 : '||MYROW.SALARY);
END;
/

-- 사번입력시 이름, 부서명, 직급명, 급여, 이메일 출력
DECLARE
   TYPE MY_RECORD IS RECORD(
       NAME    EMPLOYEE.EMP_NAME%TYPE,
       D_NAME  DEPARTMENT.DEPT_TITLE%TYPE,
       J_NAME  JOB.JOB_NAME%TYPE,
       SAL     EMPLOYEE.SALARY%TYPE,
       EMAIL   EMPLOYEE.EMAIL%TYPE
   );
   MYRECORD MY_RECORD;
BEGIN
   SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY, EMAIL
   INTO MYRECORD
   FROM EMPLOYEE
   LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
   LEFT JOIN JOB USING (JOB_CODE)
   WHERE EMP_ID='&사번';
   DBMS_OUTPUT.PUT_LINE('이름 : '||MYRECORD.NAME);
   DBMS_OUTPUT.PUT_LINE('부서명 : '||MYRECORD.D_NAME);
   DBMS_OUTPUT.PUT_LINE('직급명 : '||MYRECORD.J_NAME);
   DBMS_OUTPUT.PUT_LINE('급여 : '||MYRECORD.SAL);
   DBMS_OUTPUT.PUT_LINE('이메일 : '||MYRECORD.EMAIL);
END;
/
-------------------------------
--@실습1
--사번, 사원명, 직급코드, 급여를 담을 수 있는 참조변수를 통해서 (%TYPE)
--송종기사원의 사번, 사원명, 직급코드,급여를 익명블럭을 통해 스크립트 출력
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;

DECLARE
   ID      EMPLOYEE.EMP_ID%TYPE;
   E_NAME  EMPLOYEE.EMP_NAME%TYPE;
   J_CODE  JOB.JOB_CODE%TYPE;
   SAL     EMPLOYEE.SALARY%TYPE;
BEGIN
   SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
   INTO ID, E_NAME, J_CODE, SAL
   FROM EMPLOYEE
   LEFT JOIN JOB USING (JOB_CODE)
   WHERE EMP_NAME='송종기';
   DBMS_OUTPUT.PUT_LINE('사번 : '||ID);
   DBMS_OUTPUT.PUT_LINE('사원명 : '||E_NAME);
   DBMS_OUTPUT.PUT_LINE('직급코드 : '||J_CODE);
   DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
END;
/
--@실습2
--사번,사원명,부서명,직급명을 담을 수 있는 참조변수를 통해서 (RECORD)
--사원명을 검색하여 해당 사원의 사번, 사원명, 부서명, 직급며을 
--익명블럭을 통해 스크림트 출력
DECLARE 
    TYPE MY_RECORD IS RECORD(
       ID      EMPLOYEE.EMP_ID%TYPE,
       NAME    EMPLOYEE.EMP_NAME%TYPE,
       D_NAME  DEPARTMENT.DEPT_TITLE%TYPE,
       J_NAME  JOB.JOB_NAME%TYPE
   );
   MYRECORD MY_RECORD;
BEGIN
   SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
   INTO MYRECORD
   FROM EMPLOYEE
   LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
   LEFT JOIN JOB USING (JOB_CODE)
   WHERE EMP_NAME='&사원';
   DBMS_OUTPUT.PUT_LINE('사번 : '||MYRECORD.ID);
   DBMS_OUTPUT.PUT_LINE('사원명 : '||MYRECORD.NAME);
   DBMS_OUTPUT.PUT_LINE('부서명 : '||MYRECORD.D_NAME);
   DBMS_OUTPUT.PUT_LINE('직급명 : '||MYRECORD.J_NAME);
END;
/
--@실습3
--사원번호를 입력하여 해당 사원을 찾아 (%ROWTYPE을 사용)
--사원명,주민번호,입사일,부서명을 
--익명블럭을 통해 스크림트 출력
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;

DECLARE
    MYROW   EMPLOYEE%ROWTYPE;
    D_NAME  DEPARTMENT%ROWTYPE;
BEGIN
    SELECT EMP_NAME,EMP_NO,HIRE_DATE,DEPT_TITLE
    INTO   MYROW.EMP_NAME,MYROW.EMP_NO, MYROW.HIRE_DATE, D_NAME.DEPT_TITLE
    FROM EMPLOYEE
    JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('이름 : '||MYROW.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE('주민등록번호 : '||MYROW.EMP_NO);
    DBMS_OUTPUT.PUT_LINE('입사일 : '||MYROW.HIRE_DATE);
    DBMS_OUTPUT.PUT_LINE('부서명 : '||D_NAME.DEPT_TITLE);
END;
/
-------------------------------------------------------------------------
/*
PL/SQL 선택문

*/
--사원번호가지고 이름,급여,보너스율 출력
--보너스를 받지않으면 '보너스가 없습니다.'를 출력
DECLARE
    E_NAME  EMPLOYEE.EMP_NAME%TYPE;
    SAL     EMPLOYEE.SALARY%TYPE;
    BO      EMPLOYEE.BONUS%TYPE;
BEGIN
    SELECT EMP_NAME, SALARY, NVL(BONUS,0)
    INTO E_NAME,SAL,BO
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
    IF(BO = 0)
    THEN DBMS_OUTPUT.PUT_LINE('보너스가 없습니다.');
    ELSE DBMS_OUTPUT.PUT_LINE('보너스 : '||(BO*100)||'%');
    END IF;
END;
/
-------
--사번을 입력받은 후 급여에 따라서 등급을 나눔
--이름,급여,급여등급
--0~99 만원 :F
--100~199 : E
--200~299 : D
--300~399 : C
--400~499 : B
--500 이상 : A
DECLARE 
    E_NAME    EMPLOYEE.EMP_NAME%TYPE;
    SAL       EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT EMP_NAME, SALARY
    INTO E_NAME, SAL
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
    IF(0<=SAL AND SAL<1000000)
    THEN DBMS_OUTPUT.PUT_LINE('등급 : F');
    ELSIF(1000000<=SAL AND SAL<2000000)
    THEN DBMS_OUTPUT.PUT_LINE('등급 : E');
    ELSIF(2000000<=SAL AND SAL<3000000)
    THEN DBMS_OUTPUT.PUT_LINE('등급 : D');
    ELSIF(3000000<=SAL AND SAL<4000000)
    THEN DBMS_OUTPUT.PUT_LINE('등급 : C');
    ELSIF(4000000<=SAL AND SAL<5000000)
    THEN DBMS_OUTPUT.PUT_LINE('등급 : B');
    ELSE DBMS_OUTPUT.PUT_LINE('등급 : A');
    END IF;
END;
/
------다른버전
DECLARE 
    E_NAME    EMPLOYEE.EMP_NAME%TYPE;
    SAL       EMPLOYEE.SALARY%TYPE;
    SAL_GRADE CHAR(1);
BEGIN
    SELECT EMP_NAME, SALARY
    INTO E_NAME, SAL
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
    SAL := SAL/10000;
    IF(0<=SAL AND SAL<100) THEN SAL_GRADE := 'F';
    ELSIF (100<=SAL AND SAL<200) THEN SAL_GRADE := 'E';
    ELSIF (200<=SAL AND SAL<300) THEN SAL_GRADE := 'D';
    ELSIF (300<=SAL AND SAL<400) THEN SAL_GRADE := 'C';
    ELSIF (400<=SAL AND SAL<500) THEN SAL_GRADE := 'B';
    ELSE SAL_GRADE := 'A';
    END IF;
    DBMS_OUTPUT.PUT_LINE('등급 : '||SAL_GRADE);
END;
/
---------------------------------------------------
/*
실습문제 1
사원번호를 입력받아서 사원의 사번,이름,급여,보너스율을 출력.
직급이 대표인 경우, '저희회사 대표님이십니다.'를 출력.
*/
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;

DECLARE 
    E_ID      EMPLOYEE.EMP_ID%TYPE;
    E_NAME    EMPLOYEE.EMP_NAME%TYPE;
    SAL       EMPLOYEE.SALARY%TYPE;
    BO        EMPLOYEE.BONUS%TYPE;
    J_NAME    JOB.JOB_NAME%TYPE;
BEGIN
    SELECT EMP_ID, EMP_NAME, SALARY, NVL(BONUS,0)*100, JOB_NAME
    INTO E_ID, E_NAME,SAL,BO, J_NAME
    FROM EMPLOYEE
    JOIN JOB USING (JOB_CODE)
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('사번 : '||E_ID);
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
    DBMS_OUTPUT.PUT_LINE('보너스 : '||BO||'%');
    IF(J_NAME = '대표')
    THEN DBMS_OUTPUT.PUT_LINE('저희회사 대표님이십니다.');
    ELSE DBMS_OUTPUT.PUT_LINE('직급 : '||J_NAME);
    END IF;
END;
/
/*
실습문제 2
해당 사원 번호를 입력받아 해당 사원이 소속된 부서에서 
가장 높은 급여를 받고 있는 사원을 출력하여라
출력 값은 검색된 사원명, 검색된 사원 부서,  소속부서에서 가장 높은 급여를 받은 사원명 및 급여,부서 정보를 출력 하여라.
ex) 
사원번호 '207'번을 입력시

### 검색된 사원 정보 ###
검색된 사원명 : 하이유
소속된 부서명 : 해외영업1부
-------------------------------
### 해외영업1부에서 급여가 가장 높은 사원 정보 ###
사원명 : 대북혼
급여 : 3760000 원
소속된 부서 : 해외영업1부
*/
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;

DECLARE 
    E_NAME      EMPLOYEE.EMP_NAME%TYPE;
    D_NAME      DEPARTMENT.DEPT_TITLE%TYPE;
    MAX_SAL     EMPLOYEE.SALARY%TYPE;
    MAX_E_NAME  EMPLOYEE.EMP_NAME%TYPE;
BEGIN
    SELECT EMP_NAME, DEPT_TITLE
    INTO E_NAME, D_NAME
    FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
    WHERE EMP_ID='&사번';
    DBMS_OUTPUT.PUT_LINE('### 검색된 사원 정보 ###');
    DBMS_OUTPUT.PUT_LINE('검색된 사원명 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('소속된 부서명 : '||D_NAME);
    
    IF(D_NAME IS NOT NULL)
    THEN 
        SELECT MAX(SALARY)
        INTO MAX_SAL
        FROM EMPLOYEE 
        LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
        WHERE DEPT_TITLE = D_NAME;
    ELSE
        SELECT MAX(SALARY)
        INTO MAX_SAL
        FROM EMPLOYEE 
        WHERE DEPT_CODE IS NULL;
        D_NAME := '부서없음';
    END IF;    
    
    SELECT EMP_NAME
    INTO MAX_E_NAME
    FROM EMPLOYEE
    WHERE SALARY = MAX_SAL;
    DBMS_OUTPUT.PUT_LINE('###'||D_NAME||'에서 급여가 가장 높은 사원 정보 ###');
    DBMS_OUTPUT.PUT_LINE('사원명 : '||MAX_E_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||MAX_SAL||'원');
    DBMS_OUTPUT.PUT_LINE('소속된 부서명 : '||D_NAME);
END;
/
-------------------------------------------------------------------------
SET SERVEROUTPUT ON;

/*
반복문
BASIC LOOP : 조건없이 무한반복
*/
DECLARE
    NUM    NUMBER := 1;
BEGIN
    LOOP                 --반복시작
        DBMS_OUTPUT.PUT_LINE(NUM);
        NUM := NUM+1;
        IF (NUM > 5)
        THEN EXIT;
        END IF;
    END LOOP;            --반복 끝
END;
/

-- FOR LOOP : 반복횟수를 지정해서 반복, 반복횟수용 변수는 자동으로 선언
DECLARE
    
BEGIN
    FOR NUM IN REVERSE 1..5 LOOP                --NUM이 변수//IN다음 옵션 줄 수 있음
        DBMS_OUTPUT.PUT_LINE(NUM);
    END LOOP;
END;
/

--WHILE LOOP : 조건식이 TRUE인 동안 반복하는 반복문
--단, 처음에 조건식이 FALSE인 경우 한번도 실행하지 않을 수 있음
DECLARE
    NUM    NUMBER := 1;
BEGIN
    WHILE (NUM<=5) LOOP
        DBMS_OUTPUT.PUT_LINE(NUM);
        NUM := NUM + 1;
    END LOOP;
END;
/
----------

DECLARE
    NAME    EMPLOYEE.EMP_NAME%TYPE;
    SAL     EMPLOYEE.SALARY%TYPE;
BEGIN
    FOR NUM IN 0..22 LOOP
       SELECT EMP_NAME, SALARY
       INTO NAME, SAL
       FROM EMPLOYEE
       WHERE EMP_ID = 200+NUM;
       DBMS_OUTPUT.PUT_LINE('이름 : '|| NAME);
       DBMS_OUTPUT.PUT_LINE('급여 : '|| SAL);
    END LOOP;
END;
/
-----
SELECT * FROM EMPLOYEE;

CREATE TABLE LOOP_TEST(
   EMP_NAME     VARCHAR(20),
   DEPT_TITLE   VARCHAR2(30),
   JOB_NAME     VARCHAR2(30),
   SALARY       NUMBER
);
-- PL/SQL 반복문을 활용하여 데이터입력
-- JOIN이나 SUBQUERY 사용이 불가
-- 부서코드없는 딕원은 '부서없음'으로 부서명 입력
--1.사번이용하여 EMPLOYEE테이블에서 필요한 정보조회
-- EMP_NAME,DEPT_CODE, JOB_CODE,SALARY
--2.1의 조회결과를 이용해서 DEPARTMENT, JOB에서 추가정보조회
--3. 1,2의 조회결과를 이용하여 INSERT 작성
--4. 모든 INSERT가 종료되면 COMMIT;
------
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;
------

DECLARE
    EMP         EMPLOYEE%ROWTYPE;
    D_NAME      DEPARTMENT.DEPT_TITLE%TYPE;
    J_NAME      JOB.JOB_NAME%TYPE;
BEGIN
  FOR NUM IN 0..22 LOOP
    SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
    INTO EMP.EMP_NAME, EMP.DEPT_CODE, EMP.JOB_CODE, EMP.SALARY
    FROM EMPLOYEE
    WHERE EMP_ID = 200+NUM;
    /*
    DBMS_OUTPUT.PUT_LINE('이름 : '|| EMP.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE('부서코드 : '|| EMP.DEPT_CODE);
    DBMS_OUTPUT.PUT_LINE('직급코드 : '|| EMP.JOB_CODE);
    DBMS_OUTPUT.PUT_LINE('급여 : '|| EMP.SALARY);
    */
    IF (EMP.DEPT_CODE IS NULL)
    THEN
        D_NAME := '부서없음 ';
    ELSE
        SELECT DEPT_TITLE
        INTO D_NAME
        FROM DEPARTMENT
        WHERE DEPT_ID = EMP.DEPT_CODE;
    END IF;
    --DBMS_OUTPUT.PUT_LINE('부서명 : '|| D_NAME);
    
    SELECT JOB_NAME
    INTO J_NAME
    FROM JOB
    WHERE JOB_CODE = EMP.JOB_CODE;
    --DBMS_OUTPUT.PUT_LINE('직급명 : '|| J_NAME);
  
    INSERT INTO LOOP_TEST VALUES(EMP.EMP_NAME, D_NAME, J_NAME, EMP.SALARY);
  END LOOP;
  COMMIT;
END;
/
SELECT * FROM LOOP_TEST;
---------------------------------------------------

DECLARE
    E_NAME   EMPLOYEE.EMP_NAME%TYPE;
    SAL     EMPLOYEE.SALARY%TYPE;
    BO      EMPLOYEE.BONUS%TYPE;
BEGIN
    SELECT EMP_NAME, SALARY, 100*NVL(BONUS,0)
    INTO E_NAME, SAL, BO
    FROM EMPLOYEE
    WHERE EMP_ID = '&사번';
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
    DBMS_OUTPUT.PUT_LINE('보너스 : '||BO||'%');
EXCEPTION
    WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('직원 정보를 조회할 수 없습니다.');
END;
/
-------------------------------------------------------------------------
/*
PROCEDURE (프로시저)
-> 일련의 작업절차를 정리해서 저장해 둔것
-> 여러 SQL문을 묶어서 미리 정의하고 하나의 요청으로 실행
-> 자주사용되는 복잡한 작업들을 만들어두고 간단하게 사용이 가능
-> return void인 자바 메소드 연상

프로시저 만드는 방법
CREATE [OR REPLACE] PROCEDURE 프로시저이름(매개변수1 [변수타입] 자료형, 매개변수2 [변수타입] 자료형....)
IS
   지역변수 선언영역
BEGIN
    실행문장
END;
/
--프로시저 매개변수
1. 만약에 매개변수가 없으면 프로시저 이름까지만 작성하고 IS
    CREATE PROCEDURE 프로시저이름
    IS
2. 매개변수의 자료형을 입력할 떄 길이는 작성하지 않음(길이작성 시 에러발생)
    CREATE PROCEDURE 프로시저이름 (STR VARCHAR2)
    IS
3. 변수타입에 키둬드 [IN|OUT|INOUT]
   -> IN : 데이터를 전달 받을때 사용
   -> OUT : 결과를 받아갈 때
   -> INOUT : IN,OUT 두가지목적으로 모두 사용가능(실제로 거의 안씀)
*/
--매개변수가 없는 프로시저
CREATE OR REPLACE PROCEDURE TEST_PRO_1
IS
    NAME    EMPLOYEE.EMP_NAME%TYPE;
    SAL     EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT EMP_NAME, SALARY
    INTO NAME,SAL
    FROM EMPLOYEE
    WHERE EMP_ID=200;
    DBMS_OUTPUT.PUT_LINE('이름 : '||NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
END;
/
EXECUTE TEST_PRO_1;                           --실행방법
EXEC TEST_PRO_1;
------------
--매개변수가 있는 프로시저
--매개변수 정의 시 데이터의 길이는 입력X
CREATE OR REPLACE PROCEDURE TEST_PRO_2(E_NAME IN VARCHAR2)
IS
    D_CODE   EMPLOYEE.DEPT_CODE%TYPE;
    J_CODE   EMPLOYEE.JOB_CODE%TYPE;
    SAL      EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT DEPT_CODE, JOB_CODE, SALARY
    INTO D_CODE, J_CODE, SAL
    FROM EMPLOYEE
    WHERE EMP_NAME=E_NAME;
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME);
    DBMS_OUTPUT.PUT_LINE('부서코드 : '||D_CODE);
    DBMS_OUTPUT.PUT_LINE('직급코드 : '||J_CODE);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL);
END;
/
EXEC TEST_PRO_2('하동운');

CREATE OR REPLACE PROCEDURE TEST_PRO_3(E_NAME1 IN VARCHAR2, E_NAME2 IN EMPLOYEE.EMP_NAME%TYPE )
IS
    SAL1   EMPLOYEE.SALARY%TYPE;
    SAL2   EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT SALARY
    INTO SAL1
    FROM EMPLOYEE WHERE EMP_NAME = E_NAME1;
    SELECT SALARY
    INTO SAL2
    FROM EMPLOYEE WHERE EMP_NAME = E_NAME2;
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME1);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL1);
    DBMS_OUTPUT.PUT_LINE('이름 : '||E_NAME2);
    DBMS_OUTPUT.PUT_LINE('급여 : '||SAL2);
END;
/
EXEC TEST_PRO_3('선동일', '하이유');

--OUT 변수
CREATE OR REPLACE PROCEDURE TEST_PRO_4(
     E_NAME  IN  VARCHAR2,
     D_NAME  OUT VARCHAR2
)
IS
    D_CODE  EMPLOYEE.DEPT_CODE%TYPE;
BEGIN
    SELECT DEPT_CODE
    INTO D_CODE
    FROM EMPLOYEE WHERE EMP_NAME=E_NAME;
    
    SELECT DEPT_TITLE
    INTO D_NAME
    FROM DEPARTMENT WHERE DEPT_ID=D_CODE;
END;
/

DECLARE
   D_TITLE   DEPARTMENT.DEPT_TITLE%TYPE;
BEGIN
   --PL/SQL 내부에서 프로시저 사용시 EXEC키워드를 사용하지 않음
   TEST_PRO_4('하이유', D_TITLE);
   DBMS_OUTPUT.PUT_LINE(D_TITLE);
END;
/

CREATE TABLE EMP_PRO_TEST
AS
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
LEFT JOIN JOB USING (JOB_CODE)
ORDER BY 1;
SELECT * FROM EMP_PRO_TEST;
--1. 프로시저 생성
-- -> 매개변수로 사번을 받아서 해당 직원을 EMP_PRO_TEST테이블에서 삭제
--> COMMIT;
CREATE OR REPLACE PROCEDURE DEL_EMP_PRO1(
    E_ID   NUMBER
)
IS
BEGIN
    DELETE FROM EMP_PRO_TEST WHERE EMP_ID = E_ID;
    COMMIT;
END;
/

EXEC DEL_EMP_PRO1(205);
SELECT * FROM EMP_PRO_TEST;

------------------
--
/*
1.신규테이블 생성
   -> 테이블이름 DEL_EMP
   -> 사번,이름,부서명,직급명,퇴사일 저장할 컬럼 존재
2. DEL_EMP_PRO2 프로시저 생성
   -> 매개변수로 사번을 받음
   ->매개변수로 받은 사원정보를 EMP_PRO_TEST테이블에서 삭제
   ->EMP_PRO_TEST테이블 삭제전에 필요한 정보를 조회해서 DEL_EMP에 INSERT 한 후 삭제(퇴사일 SYSDATE로 입력)
   -> COMMIT   
*/
--SELECT * FROM EMPLOYEE;
--DROP TABLE DEL_EMP;

CREATE TABLE DEL_EMP(
    EMP_ID NUMBER, 
    EMP_NAME VARCHAR2(20), 
    DEPT_TITLE  VARCHAR2(50), 
    JOB_NAME VARCHAR2(30) ,
    DEL_DATE   DATE
);
--SELECT * FROM DEL_EMP;
CREATE OR REPLACE PROCEDURE DEL_EMP_PRO2(
    E_ID   NUMBER
)
IS
    DEL_ID   EMP_PRO_TEST.EMP_ID%TYPE;
    DEL_NAME  EMP_PRO_TEST.EMP_NAME%TYPE;
    DEL_TITLE  EMP_PRO_TEST.DEPT_TITLE%TYPE;
    DEL_J_NAME  EMP_PRO_TEST.JOB_NAME%TYPE;
BEGIN
    SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
    INTO DEL_ID, DEL_NAME, DEL_TITLE, DEL_J_NAME
    FROM EMP_PRO_TEST
    WHERE EMP_ID = E_ID;
    
    INSERT INTO DEL_EMP VALUES (DEL_ID, DEL_NAME, DEL_TITLE, DEL_J_NAME,SYSDATE);
    
    DELETE FROM EMP_PRO_TEST WHERE EMP_ID = E_ID;
    COMMIT;
END;
/

EXEC DEL_EMP_PRO2(209);
SELECT * FROM EMP_PRO_TEST;
SELECT * FROM DEL_EMP;
----------------------------
/*
FUNCTION : 프로시저와 거의 유사
-> 리턴이 반드시 존재
-> IN|OUT 타입변수 사용X
SUBSTR, FLOOR과 유사

함수 작성방법
CREATE [OR REPLACE] FUNCTION 함수이름(매개변수1 자료형, 매개변수2 자료형)
RETURN 리턴자료형
IS
BEGIN
END;
/

*/
--부서코드를 받아서 부서명을 조회하는 함수 생성 
CREATE OR REPLACE FUNCTION GET_DEPT(D_CODE VARCHAR2)
RETURN DEPARTMENT.DEPT_TITLE%TYPE
IS
    D_NAME   DEPARTMENT.DEPT_TITLE%TYPE;
BEGIN
    SELECT DEPT_TITLE
    INTO D_NAME
    FROM DEPARTMENT
    WHERE DEPT_ID = D_CODE;
    RETURN D_NAME;
END;
/

SELECT GET_DEPT('D9') FROM DUAL;
SELECT EMP_NAME, DEPT_CODE, GET_DEPT(DEPT_CODE) FROM EMPLOYEE;

--급여랑 보너스를 매개변수로 받아서 연봉을 계산해서 리턴
CREATE OR REPLACE FUNCTION GET_YEAR_SAL(
   SAL NUMBER, 
   BO NUMBER
)
RETURN NUMBER
IS
   YEAR_SAL    NUMBER;
BEGIN
   YEAR_SAL := (SAL+SAL*BO)*12;
   RETURN YEAR_SAL;
END;
/
SELECT GET_YAER_SAL(5000000,0.1) FROM DUAL;
SELECT EMP_NAME, SALARY, GET_YEAR_SAL(SALARY,NVL(BONUS,0))
FROM EMPLOYEE;
---------
--매개변수로 사번받아서 해당사원 연봉을 리턴하는 함수
CREATE OR REPLACE FUNCTION GET_YEAR_SAL2(
   E_ID   NUMBER
)
RETURN NUMBER
IS
   SAL EMPLOYEE.SALARY%TYPE;
   BO  EMPLOYEE.BONUS%TYPE;
   YEAR_SAL NUMBER;
BEGIN
   SELECT  SALARY, NVL(BONUS,0)
   INTO SAL, BO
   FROM EMPLOYEE WHERE EMP_ID = E_ID;
   YEAR_SAL := (SAL+SAL*BO)*12;
   RETURN YEAR_SAL;
END;
/
SELECT EMP_NAME, GET_YEAR_SAL2(EMP_ID) FROM EMPLOYEE;
--------------------------------------
--
/*
TRIGGER : 미리 정해놓은 조건을 만족하거나 수행되면 자동적으로 수행되는 행동
   -> 특정테이블이나 뷰에 INSERT,UPDATE,DELETE의 DML에의해
   -> 입력,수정, 삭제가 되는경우 자동으로 실행
*/
--회원정보를 저장하는 테이블
CREATE TABLE M_TBL(
    MEMBER_ID   VARCHAR2(20) PRIMARY KEY, --아이디
    MEMBER_PW   VARCHAR2(30) NOT NULL, --비밀번호
    MEMBER_NAME  VARCHAR2(20) NOT NULL, --이름
    ENROLL_DATE  DATE                  --가입일
);
--M_TBL 정보가 변경되면 변경이력을 저장하는 테이블(비밀번호 변경) 
CREATE TABLE M_LOG(
    MEMBER_ID   VARCHAR2(20) REFERENCES M_TBL ON DELETE CASCADE,
    CHANGE_CONTENT  VARCHAR2(100),--비밀번호 변경내역
    CHANGE_DATE  DATE             --변경날짜
);
--M_TBL에서 회원이 탈퇴한경우 탈퇴이력을 저장하는 테이블
CREATE TABLE DEL_M_TBL(
    MEMBER_ID   VARCHAR2(20)   PRIMARY KEY,--탈퇴회원 아이디
    MEMBER_NAME  VARCHAR2(20),             --탈퇴회원 이름
    ENROLL_DATE  DATE,                     --탈퇴회원 가입일
    OUT_DATE   DATE                        --탈퇴 날짜
);
/*
FOR EACH ROW가 있는경우
업테이트문 동작 -> 5개행이 수정 -> TRIGGER 5회 동작
FOR EACH ROW가 없는경우
업테이트문 동작 -> 5개행이 수정 -> TRIGGER 1회 동작
------
CREATE OR REPLACE] TRIGGER 트리거이름
동작시점   동작DML  (EX. AFTER INSERT)
ON 대상테이블
[FOR EACH ROW]   --트리거 종류(변경된 행의 수만큼 트리거동작)
BEGIN
    --실행코드영역
END;
/
바인드변수(FOR EACH ROW를 사용할때만 사용가능한 변수)
:NEW - SQL문으로 새로 입력된 데이터      --INSERT는 NEW밖에 사용못함
:OLD - SQL문으로 변경되기 전 데이터
:NEW.컬럼명
:OLD.컬럼명
*/
-- M_TBL에 회원이 INSERT되면 '회원이 추가되었습니다.' 메세지 출력하는 TRIGGER
CREATE OR REPLACE TRIGGER M_TBL_INSERT_TRG
AFTER INSERT 
ON M_TBL
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.MEMBER_NAME||'회원이 추가되었습니다.');
END;
/
INSERT INTO M_TBL
VALUES('user01','1111','유저1',SYSDATE-1);
INSERT INTO M_TBL
VALUES('user02','2222','유저2',SYSDATE-1);
INSERT INTO M_TBL
VALUES('user03','3333','유저3',SYSDATE-1);
COMMIT;
SELECT * FROM M_TBL;

-- M_TBL에서 비밀번호를 변경하면 변경이력을 M_LOG_TBL에 INSERT하는 TRIGGER

CREATE OR REPLACE TRIGGER M_TBL_PW_TRG
AFTER UPDATE
ON M_TBL
FOR EACH ROW
BEGIN
    INSERT INTO M_LOG
    VALUES(:OLD.MEMBER_ID, :OLD.MEMBER_PW||'->'||:NEW.MEMBER_PW, SYSDATE);
END;
/
SELECT * FROM M_TBL;
SELECT * FROM M_LOG;
UPDATE M_TBL SET MEMBER_PW = '1234' WHERE MEMBER_ID='user01';

-- M_TBL에서 데이터 삭제 시 DEL_M_TBL에 데이터를 INSERT하는 TRIGGER
CREATE OR REPLACE TRIGGER M_TBL_DEL_TRG
AFTER DELETE
ON M_TBL
FOR EACH ROW
BEGIN
    INSERT INTO DEL_M_TBL
    VALUES(:OLD.MEMBER_ID, :OLD.MEMBER_NAME, :OLD.ENROLL_DATE, SYSDATE);
END;
/
DESC DEL_M_TBL;
SELECT * FROM M_TBL;
SELECT * FROM DEL_M_TBL;
DELETE FROM M_TBL WHERE MEMBER_ID='user03';
--------
-------
CREATE TABLE PRODUCT(
   PCODE   NUMBER  PRIMARY KEY,      --상품코드
   PNAME   VARCHAR2(50)   NOT NULL,  --상품이름
   PRICE   NUMBER,                   --가격
   STOCK   NUMBER                    --재고
);
CREATE TABLE PRO_DETAIL(
   DCODE   NUMBER    PRIMARY KEY,  --입/출고 번호
   PCODE   NUMBER  REFERENCES PRODUCT, --상품코드
   D_DATE   DATE,                    --입/출고 날짜
   AMOUNT  NUMBER,                   --입/출고 수량
   STATUS  CHAR(6) CHECK(STATUS IN ('입고','출고')) --구분
);
INSERT INTO PRODUCT
VALUES(PCODE_SEQ.NEXTVAL,'마사지볼','10000',20);
INSERT INTO PRODUCT
VALUES(PCODE_SEQ.NEXTVAL,'핸드크림',9000,10);
CREATE SEQUENCE PCODE_SEQ;
CREATE SEQUENCE DCODE_SEQ;
SELECT * FROM PRODUCT;
SELECT * FROM PRO_DETAIL;
COMMIT;
INSERT INTO PRO_DETAIL
VALUES(DCODE_SEQ.NEXTVAL, 2,SYSDATE,10,'입고');
UPDATE PRODUCT SET STOCK = 20 WHERE PCODE=2;
INSERT INTO PRO_DETAIL
VALUES(DCODE_SEQ.NEXTVAL, 1,SYSDATE,5,'출고');
UPDATE PRODUCT SET STOCK = 15 WHERE PCODE=1;
---
CREATE OR REPLACE TRIGGER PRODUCT_TRG
AFTER INSERT 
ON PRO_DETAIL
FOR EACH ROW
BEGIN
    IF (:NEW.STATUS='입고')
    THEN
        UPDATE PRODUCT SET STOCK = STOCK + :NEW.AMOUNT 
        WHERE PCODE=:NEW.PCODE;
    ELSE
        UPDATE PRODUCT SET STOCK = STOCK - :NEW.AMOUNT 
        WHERE PCODE=:NEW.PCODE;
    END IF;
END;
/
INSERT INTO PRO_DETAIL
VALUES(DCODE_SEQ.NEXTVAL, 2,SYSDATE,3,'출고');

SELECT * FROM PRODUCT;
SELECT * FROM PRO_DETAIL;
------------------------------------
시험범위
10~13 PDF
---------------------------------------

